//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import '@chainlink/contracts/src/v0.8/VRFConsumerBase.sol';
import './Lootbox.sol';

contract ChainlinkLootbox is Lootbox, VRFConsumerBase {
    struct Box {
        address account;
        uint256 typeId;
    }

    mapping(bytes32 => Box) public requestIdToBox;

    uint256 public chainlinkFee;
    bytes32 internal keyHash;

    event BoxOpeningRequested(bytes32 indexed requestId);

    constructor(
        address coordinator_,
        address link_,
        uint256 chainlinkFee_,
        bytes32 keyHash_,
        address nft_,
        address utilityToken_,
        address treasury_,
        uint8 maxQuantity_
    ) VRFConsumerBase(coordinator_, link_) Lootbox(nft_, utilityToken_, treasury_, maxQuantity_) {
        chainlinkFee = chainlinkFee_;
        keyHash = keyHash_;
    }

    function _openBox(uint256 typeId, uint256) internal override {
        require(LINK.balanceOf(address(this)) >= chainlinkFee, 'Not enough LINK - impossible to create random');
        bytes32 requestId = requestRandomness(keyHash, chainlinkFee);
        requestIdToBox[requestId] = Box({ account: msg.sender, typeId: typeId });
        emit BoxOpeningRequested(requestId);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        _getOutcome(requestIdToBox[requestId].account, requestIdToBox[requestId].typeId, randomness);
    }

    function withdrawLink(uint256 value) external onlyOwner {
        LINK.transfer(msg.sender, value);
    }
}
